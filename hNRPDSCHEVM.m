function [evm,eqSym,refSym,plots] = hNRPDSCHEVM(waveConfig,rxWaveform,cfg,varargin)
%hNRPDSCHEVM EVM calculation
%	[EVM,EQSYM,REFSYM,PLOTS] = hNRPDSCHEVM(WAVECONFIG,RXWAVEFORM,CFG)
%	Calculates the error vector magnitude (EVM) of a received waveform or 3GPP
%	specified EVM algorithm as defined in TS 38.104, Annex B(FR1) / Annex C(FR2)
%
%   EVM is a (2 x Number of Slots) cell array of EVM statistics. The first
%   cell contains EVM per PDSCH slot and per window location, while the
%   second cell contains peak and RMS EVM for the overall waveform). When
%   EVM is not measured according to 3GPP standard, only one window
%   location is used.
%	EQSYM is a (2 x Number of Slots) cell array of decoded IQ
%	constellations for low & high EVM window locations.
%   REFSYM is a (2 x Number of Slots) cell array of reference IQ
%   constellations for low and high EVM window locations.
%	PLOTS is an array of objects for the plots produced in this function.
%	WAVECONFIG contains carrier and cell related parameters.It is either an
%	object of type 'nrDLCarrierConfig' or a struct.
%	RXWAVEFORM Time domain baseband IQ samples. Timing of the waveform is
%	assumed to be aligned to slot 0 with sample level fine-tuning performed
%   subsequently. The length of the waveform can be an arbitrary number of
%   slots.
%   CFG is a struct with the fields:
%   Evm3GPP         - Enables or disables 3GPP method of EVM computation.
%                     (Default value : false)
%   TargetRNTIs     - Contains the list of target RNTIs to decode. If not
%                     specified, the list is autogenerated as specified in
%                     the standard.
%                     (Default value : Empty)
%   PlotEVM         - Enables or disables plotting of EVM (per slot, per
%                     symbol, per subcarrier and overall EVM).
%                     (Default value : true)
%   DisplayEVM      - Enables or disables the display of
%                     EVM statistics on the command window.
%                     (Default value : true)
%   Label           - A character vector or a string scalar indicating
%                     the name of NR-TM or FRC. It is used to extract the
%                     NR-TM/FRC label when WAVECONFIG is an object of type
%                     'nrDLCarrierConfig'.If unused, ensure TargetRNTIs is
%                     not empty. This parameter is not used when WAVECONFIG
%                     is of type struct.
%   [EVM,EQSYM,REFSYM,PLOTS] = hNRPDSCHEVM(...,WAVEFORMRESOURCES) specifies
%                     a structure array of slot-wise PDSCH resources used
%                     for EVM calculation.

% Copyright 2020 The MathWorks, Inc.

    narginchk(3,4);
    
    if nargin == 3 % No optional inputs
        waveformResources = [];
    else
        waveformResources = varargin{1};
    end
    if ~isfield(cfg,'Evm3GPP')
        evm3GPP = false;
    else
        evm3GPP = cfg.Evm3GPP;
    end
    if ~isfield(cfg,'TargetRNTIs')
        targetRNTIs = [];
    else
        targetRNTIs = cfg.TargetRNTIs;
    end
    if ~isfield(cfg,'PlotEVM')
        plotEVM = true;
    else
        plotEVM = cfg.PlotEVM;
    end
    if ~isfield(cfg,'DisplayEVM')
        displayEVM = true;
    else
        displayEVM = cfg.DisplayEVM;
    end
    if ~isfield(cfg,'Label')
        label = '';
    else
        label = cfg.Label;
    end

    % Get per-slot PDSCH resources (waveformResources) used as reference for EVM calculation
    % Derive these resources if waveformResources is absent
    useStruct = false;
    if nargin ~= 4
        [~,winfo] = nrWaveformGenerator(waveConfig);
        waveformResources = winfo.WaveformResources;
        waveformResources.Label = label;
    else
        if isstruct(waveConfig)
            useStruct = true;
        end
    end
    % waveConfig can be an object of type 'nrDLCarrierConfig' or a struct.
    % useStruct is a switch for extracting fields from waveConfig.PDSCH
    [pdschArray,~,carrier] = hListTargetPDSCHs(waveConfig,waveformResources,targetRNTIs);
    % Ensure modulation is same across the valid RNTI set.
    pdschConfigLen = length(pdschArray);
    if pdschConfigLen > 1
        for idx = 2:pdschConfigLen
            if ~(strcmp(pdschArray(idx-1).PDSCH.Modulation,pdschArray(idx).PDSCH.Modulation))
                error('All RNTIs must have the same modulation.');
            end
        end
    end

    % Obtain OFDM related info
    ofdmInfo = nrOFDMInfo(carrier);
    ofdmInfo.SamplesPerSubframe = sum(ofdmInfo.SymbolLengths);
    % Generate a reference grid of length two frames for timing synchronization
    refGrid = referenceGrid(carrier,pdschArray,ofdmInfo.SlotsPerFrame*2);
    % Time synchronization of input waveform.
    offset = nrTimingEstimate(carrier,rxWaveform,refGrid);
    rxWaveform = rxWaveform(1+offset:end,:);

    % Calculate number of subframes, slots and frames
    nSubframes = floor(size(rxWaveform, 1)/ofdmInfo.SamplesPerSubframe);
    nSlots = nSubframes*ofdmInfo.SlotsPerSubframe;
    nFrames = floor(nSlots/(10*ofdmInfo.SlotsPerSubframe));

    % Generate a reference grid for slots corresponding to the length of
    % the input waveform. This grid contains only the DM-RS and is
    % primarily used for channel estimation.
    refGrid = referenceGrid(carrier,pdschArray,nSlots);

    % Slot allocation of the PDSCH configurations may overlap with each
    % other. Extract unique allocated slots.
    activeSlots = [];
    for pIdx = 1:pdschConfigLen
        if ~isempty(pdschArray(pIdx).Resources)
            activeSlots = [activeSlots pdschArray(pIdx).Resources.NSlot]; %#ok<*AGROW>
        end
    end
    activeSlots = unique(activeSlots);

    % Declare storage variables
    eqSym = cell(2,1);                  % Equalized symbols for constellation plot, for low/high EVM window locations
    refSym = cell(2,1);                 % Reference symbols for constellation plot, for low/high EVM window locations
    rxGridLow = [];                     % Demodulated OFDM grid, for 1st CP position
    rxGridHigh = [];                    % Demodulated OFDM grid, for 2nd CP position
    HestLow = [];                       % Channel estimation for 1st CP position
    HestHigh = [];                      % Channel estimation for 2nd CP position

    % Restrict CP length as per TS 38.104, Annex B.5.1 (FR1) / Annex C.5.1 (FR2)
    cpLength = double(ofdmInfo.CyclicPrefixLengths(2));
    L = carrier.SymbolsPerSlot;

    if plotEVM
        [evmGridFigure,evmSymbolPlot,evmSubcarrierPlot,evmSlotPlot] = hNREVMPlots();
        if (nSlots > 0)
            evmSymbolPlot.TimeSpan = (L*nSlots);
            evmSlotPlot.TimeSpan = nSlots;
        end
    end

    % If the waveform contains an encoded transport block, generate
    % reference paramters needed for decoding and re-encoding.
    % The re-encoded IQ samples are used as a reference for EVM calculation.
    % A single PDSCH config is assumed for processing here.
    if useStruct
       pdschEncodingOn = waveConfig.PDSCH(1).EnableCoding;
    else
       pdschEncodingOn = waveConfig.PDSCH{1}.Coding;
    end
    if pdschEncodingOn
        pdsch = pdschArray(1).PDSCH;
        if isempty(pdsch.NID)
            pdsch.NID = carrier.NCellID;
        end
        if useStruct
            pdsch.PRBSet = pdsch.AllocatedPRB;
            pdsch.SymbolSet = pdsch.AllocatedSymbols;
            nLayers = pdsch.NLayers;
        else
            nLayers = pdsch.NumLayers;
        end
        decodeDLSCH = nrDLSCHDecoder;
        decodeDLSCH.TargetCodeRate = pdsch.TargetCodeRate;
        decodeDLSCH.LDPCDecodingAlgorithm = 'Normalized min-sum';
        dlsch = nrDLSCH('MultipleHARQProcesses',false);
    end

    frameEVM = repmat(hEVM([]), 1, max(nFrames,1));
    evm = repmat(hEVM([]), 2, nSlots);

    % When evm3GPP is true, two EVM window locations and two CP fractions
    % are selected for 3GPP EVM for OFDM demodulation. If false, a single
    % EVM window location is used, which is centred in the middle of the CP.
    if evm3GPP
        W = getEVMWindow(carrier,waveConfig.FrequencyRange,waveConfig.ChannelBandwidth,ofdmInfo.Nfft);
        if (mod(W,2) == 0)
            alpha = 0;
        else
            alpha = 1;
        end
        nEVMWindowLocations = 2;
        cpFraction = [0 ; W/cpLength];
    else
        nEVMWindowLocations = 1;
        cpFraction = 0.5;      % Use default value
    end
    for subframeIdx = 0:(nSubframes)-1
        % Extract this subframe.
        rxSf = rxWaveform(subframeIdx*ofdmInfo.SamplesPerSubframe+(1:(ofdmInfo.SamplesPerSubframe)), :);
        % For low edge EVM and high edge EVM:
        % Compute EVM window edge position and perform OFDM
        % demodulation. The standard defines window position in
        % samples, the 5G Toolbox(TM) requires it as a fraction of the
        % cyclic prefix length.
        rxGridLow = [rxGridLow nrOFDMDemodulate(carrier, rxSf, 'CyclicPrefixFraction',cpFraction(1))];
        if nEVMWindowLocations == 2
            rxGridHigh = [rxGridHigh nrOFDMDemodulate(carrier, rxSf, 'CyclicPrefixFraction',cpFraction(2))];
        end
    end

    % For 3GPP EVM processing, extract IQ samples in blocks of 10 ms each (TS 38.104, Annex B.6/C.6)
    nSlots10Ms = min(nSlots,10*carrier.SubcarrierSpacing/15);
    nBlocks = ceil(nSlots/nSlots10Ms);                  % Each block is 10 ms in length, can go upto 2 for TDD FRC
    if evm3GPP
        % For each 10 ms block, estimate the channel coefficients
        for blkIdx = 0:(nBlocks-1)
            % Index of symbols within current block. If a symbol index exceeds
            % the length of the received grid remove it.
            symIdx = blkIdx*L*nSlots10Ms+(1:(L*nSlots10Ms));
            symIdx(symIdx>size(rxGridLow, 2)) = [];
            HestLowBlk = hChannelEstimateEVM3GPP(rxGridLow(:, symIdx, :),refGrid(:, symIdx,:));
            HestHighBlk = hChannelEstimateEVM3GPP(rxGridHigh(:, symIdx, :),refGrid(:, symIdx,:));
            HestLow = [HestLow HestLowBlk];
            HestHigh = [HestHigh HestHighBlk];
        end
    else
        % Compute channel estimates for each slot
        for slotIdx = 1:nSlots
            symIdx = (slotIdx-1)*L+1:slotIdx*L;
            symIdx(symIdx>size(rxGridLow, 2)) = [];
            HestLowBlk = nrChannelEstimate(rxGridLow(:, symIdx, :),refGrid(:, symIdx,:));
            HestLow = [HestLow HestLowBlk];
        end
    end
    [numSCs,numSymb] = size(rxGridLow);
    % In case of non-3GPP case, only a single EVM grid is used.
    evmGridEdge = zeros(2,numSCs,numSymb);
    % Compute the DL EVM for each active/valid DL slot, store the results
    % in a cell-array for later processing. Skip slots which are not DL.
    % For each valid slot, update the plot (symbol,SC,RB,grid-wise)
    slotRange = activeSlots(activeSlots < nSlots);
    if isempty(slotRange)
        slotRange = [];
        plotEVM = false;
        warning('No scheduled slots found for EVM processing.');
    end
    for slotIdx=slotRange
        carrier.NSlot = slotIdx;
        [pdschIndices,refSymbols] = hSlotResources(pdschArray,slotIdx);
        % Do not include first two slot symbols for PDSCH EVM (used for
        % control as specified in TS 38.141-1 table 4.9.2.2-2 (NR-TMs) / 
        % TS 38.101-1 table A.3.1-1 (FRCs))
        idx = pdschIndices <= 2*numSCs;
        pdschIndices(idx) = [];
        refSymbols(idx) = [];

        [pdschRxLow,pdschHestLow] = nrExtractResources(pdschIndices,rxGridLow(:, slotIdx*L+(1:L), :),HestLow(:, slotIdx*L+(1:L), :, :));
        noiseEst = 0;           % ZF based equalization, as per TS 38.104, Annex B.1(FR1) / Annex C.1(FR2)
        if evm3GPP
            [pdschRxHigh,pdschHestHigh] = nrExtractResources(pdschIndices,rxGridHigh(:, slotIdx*L+(1:L), :),HestHigh(:, slotIdx*L+(1:L), :, :));
            [eqGridHigh,csiHigh] = nrEqualizeMMSE(pdschRxHigh,pdschHestHigh,noiseEst);
            eqSym{2} = [eqSym{2}; eqGridHigh];
        end
        [eqGridLow,csiLow] = nrEqualizeMMSE(pdschRxLow,pdschHestLow,noiseEst);
        eqSym{1} = [eqSym{1}; eqGridLow];

        if pdschEncodingOn
            resourceIdx = find(slotIdx == slotRange);
            trBlkSizes = pdschArray.Resources(resourceIdx).TransportBlockSize;
            G = pdschArray.Resources(resourceIdx).G;
        end
        % For low edge EVM and high edge EVM
        for e = 1:nEVMWindowLocations
            % Select the low or high edge equalizer output
            if (e == 1)
                edge = 'Low edge';
                if nEVMWindowLocations == 1
                    edge = '';              % Print only single EVM per slot
                end
                eqGrid = eqGridLow;
                csi = csiLow;
            else
                edge = 'High edge';
                eqGrid = eqGridHigh;
                csi = csiHigh;
            end
            if (~pdschEncodingOn)           % For NR-TM mode
                rxSymbols = eqGrid;
            else                            % decode rxSymbols. If CRC passes, re-encode them for obtaining reference IQs for EVM calculation
                [dlschLLRs,rxSymbols] = nrPDSCHDecode(eqGrid,pdsch.Modulation,pdsch.NID,pdsch.RNTI,noiseEst);
                % Scale LLRs by CSI
                numCWs = size(dlschLLRs,2);
                csi = nrLayerDemap(csi);    % CSI layer demapping
                for cwIdx = 1:numCWs
                    Qm = length(dlschLLRs{cwIdx})/length(rxSymbols{cwIdx}); % bits per symbol
                    csi{cwIdx} = repmat(csi{cwIdx}.',Qm,1);   % expand by each bit per symbol
                    dlschLLRs{cwIdx} = dlschLLRs{cwIdx} .* csi{cwIdx}(:);   % scale
                end
                decodeDLSCH.TransportBlockLength = trBlkSizes;
                [demodBits,blkerr] = decodeDLSCH(dlschLLRs,pdsch.Modulation,nLayers,pdsch.RVSequence(1));
                if any(blkerr)
                    warning('CRC failed on decoded data, using sliced received symbols, EVM may be inaccurate.');
                    % Attempt to gracefully handle bad CRC. Generate some
                    % bits for this slot by hard slicing LLRs, so that the
                    % simulation can continue.
                    recodedBits = cellfun(@(x) x<0, dlschLLRs, 'UniformOutput', false);
                else
                    trBlk = demodBits;
                    dlsch.TargetCodeRate = decodeDLSCH.TargetCodeRate;
                    setTransportBlock(dlsch,trBlk);
                    recodedBits = dlsch(pdsch.Modulation,nLayers,G,pdsch.RVSequence(1));
                end
                
                refSymbols = nrPDSCH(recodedBits,pdsch.Modulation,nLayers,pdsch.NID,pdsch.RNTI);
            end
            if pdschEncodingOn
                rxSymbols = cell2mat(rxSymbols);
            end
            refSym{e} = [refSym{e}; refSymbols];
            evm(e,slotIdx+1) = hEVM(rxSymbols,refSymbols);
            if displayEVM
                fprintf('%s RMS EVM, Peak EVM, slot %d: %0.3f %0.3f%%\n',edge,slotIdx,evm(e, slotIdx+1).RMS*100,evm(e, slotIdx+1).Peak*100);
            end
        end
        % Update EVM plots
        if plotEVM
            % Build low and high edge EVM resource grids across all slots (for plotting)
            evmSlotEdge = zeros(2,numSCs,ofdmInfo.SymbolsPerSlot);
            numSymbPerSlot = ofdmInfo.SymbolsPerSlot;
            evmSlotEdge(1,pdschIndices) = abs(evm(1,slotIdx+1).EV)*100;
            evmGridEdge(1,:,numSymbPerSlot*slotIdx+1:numSymbPerSlot*(slotIdx+1)) =  evmSlotEdge(1,:,:);
            if evm3GPP
                evmSlotEdge(2,pdschIndices) = abs(evm(2,slotIdx+1).EV)*100;
                evmGridEdge(2,:,numSymbPerSlot*slotIdx+1:numSymbPerSlot*(slotIdx+1)) =  evmSlotEdge(2,:,:);
            end
            % The low or high edge timing is chosen for plotting
            % automatically based on whichever has the largest RMS across
            % all slots (Largest RMS chosen as mentioned in TS 38.104 , Annex B.7)
            evmGrid = squeeze(evmGridEdge(1,:,:));
            evmSlot = squeeze(evmSlotEdge(1,:,:)); %#ok<*NASGU>
            if evm3GPP
                evmMaxLow = max([evm(1,:).RMS]);
                evmMaxHigh = max([evm(2,:).RMS]);
                if evmMaxHigh > evmMaxLow
                    evmGrid = squeeze(evmGridEdge(2,:,:));
                    evmSlot = squeeze(evmSlotEdge(2,:,:));
                end
            end
            % maximum EVM, used for plot limits scaling
            maxEVM = max(evmGrid(:),[],1);
            updateEVMPlots(evmGridFigure,evmSubcarrierPlot,maxEVM,evmGrid);
        end
    end

    if plotEVM
        % Plot EVM versus OFDM symbol
        evmSymbolRMS = sqrt(sum(evmGrid.^2,1)./sum(evmGrid~=0,1)).';
        evmSymbolPeak = (max(evmGrid,[],1)./any(evmGrid,1)).';
        evmSymbolPlot([evmSymbolRMS evmSymbolPeak]);
        yLimits = [0 maxEVM*1.1];
        evmSymbolPlot.YLimits = yLimits;
        
        % Plot EVM versus Slot
        evmSlotRMS = [];
        evmSlotPeak = [];
        for sIdx = 1:nSlots
            evmSlotRMSTmp = max(evm(1:nEVMWindowLocations,sIdx).RMS)*100;
            evmSlotPeakTmp = max(evm(1:nEVMWindowLocations,sIdx).Peak)*100;
            if isempty(evmSlotPeakTmp)
                evmSlotPeakTmp = NaN;
            end
            evmSlotRMS= [evmSlotRMS;evmSlotRMSTmp]; 
            evmSlotPeak = [evmSlotPeak;evmSlotPeakTmp];
        end
        evmSlotPlot([evmSlotRMS evmSlotPeak]);
        evmSymbolPlot.YLimits = yLimits;
        evmSlotPlot.YLimits = yLimits;
    end
    print3GPPFrameAvg = 1;      % Ensures only fully occupied frames are printed
    % After we've filled a frame or if we're at the end of a signal
    % shorter than a frame, do EVM averaging
    if (nFrames == 0)
        nFrames = 1;     % Below loop needs to run atleast once
        print3GPPFrameAvg = 0; % Dont print low/high EVM as we dont have sufficient slots to fill up a frame
    end

    % 1-based indexing for accessing evm
    % Limit frame-averaging to complete frames only
    slotRange = slotRange+1;
    slotRange = slotRange(slotRange <= (nFrames*10*ofdmInfo.SlotsPerSubframe));
    % loop through each frame, selecting the frames with higher RMS( when
    % measuring 3GPP EVM)
    for frameIdx = 0:nFrames-1
        frameLowEVM = hEVM(cat(1,evm(1,slotRange).EV));
        frameEVM(frameIdx+1) = frameLowEVM;
        if evm3GPP
            frameHighEVM = hEVM(cat(1,evm(2,slotRange).EV));
            if frameHighEVM.RMS > frameLowEVM.RMS
                frameEVM(frameIdx+1) = frameHighEVM;
            end
        end
        if print3GPPFrameAvg && evm3GPP && displayEVM
            fprintf('Averaged low edge RMS EVM,frame %d: %0.3f%%\n',frameIdx,frameLowEVM.RMS*100);
            fprintf('Averaged high edge RMS EVM,frame %d: %0.3f%%\n',frameIdx,frameHighEVM.RMS*100);
            fprintf('Averaged RMS 3GPP EVM frame %d: %0.3f%%\n',frameIdx,frameEVM(frameIdx+1).RMS*100);
        end
    end
    % Display final averaged EVM across all frames
    finalEVM = hEVM(cat(1,frameEVM(:).EV));
    if displayEVM
        fprintf('Averaged overall RMS EVM: %0.3f%%\n', finalEVM.RMS*100);
    end
    % Create array of plots
    if plotEVM
        plots = {evmSymbolPlot,evmSubcarrierPlot,evmSlotPlot,evmGridFigure};
    else
        plots = {};
    end
    evm = {evm;finalEVM};
    if plotEVM
        % Display the constellation diagram
        figure
        eqPlot = plot(eqSym{1},'.'); hold on
        refPlot = plot(refSym{1},'+');
        title('Equalized symbols constellation')
        plots = {plots;eqPlot;refPlot};
    end
    if displayEVM
        disp("Peak EVM = " + string((evm{2,1}.Peak)*100) + "%");
    end
end

function updateEVMPlots(evmGridFigure,evmSubcarrierPlot,maxEVM,evmGrid)
    % Plot EVM versus subcarrier
    evmSubcarrierRMS = sqrt(sum(evmGrid.^2,2)./sum(evmGrid~=0,2));
    evmSubcarrierPeak = max(evmGrid,[],2)./any(evmGrid,2);
    evmSubcarrierPlot([evmSubcarrierRMS evmSubcarrierPeak]);
    evmSubcarrierPlot.YLimits = [0 maxEVM*1.1];
    % Plot EVM resource grid
    evmGridFigure = hNREVMPlots(evmGridFigure, evmGrid);
    evmGridFigure.CurrentAxes.ZLim = [0 maxEVM*1.1];
end

function W = getEVMWindow(carrier,frequencyRange,channelBandwidth,nFFT)
%   W = getEVMWindow(CARRIER,FREQUENCYRANGE,CHANNELBANDWIDTH,NFFT) is the
%   error vector magnitude window length, as mentioned in TS 38.104, Section
%   B.5.2 < FR1 /FR2 >. W is defined for a given combination of subcarrier
%   spacing, channel bandwidth/fft length, frequency range and CP type. W
%   is subsequently used as an intermediate value to decide the CP Fraction
%   for OFDM demodulation.

    scsFR1 = [15 30 60];
    scsFR2 = [60 120];
    % BW MHz        5  10 15 20  25  30  40  50  60  70  80  90  100
    channelBwFR1 = [5  10 15 20  25  30  40  50  60  70  80  90  100];
    nfftFR1 = [256 384 512 768 1024 1536 2048 3072  4096];
    WsFR1   = [NaN NaN  14 NaN   28   44   58  108   144;      % NormalCp, 15kHz
                 8 NaN  14  22   28   54   72  130   172;      % NormalCp, 30kHz
                 8  11  14  26   36   64   86  NaN   NaN;      % NormalCp, 60kHz
                54  80 106 164  220  340  454  NaN   NaN];     % ExtendedCp, 60kHz

    % BW MHz        50 100 200 400
    channelBwFR2 = [50 100 200 400];
    nfftFR2 = [512 1024 2048 4096];
    WsFR2        = [NaN  36  72  144;                           % NormalCP, 60kHz
                    18   36  72  144;                          % NormalCP, 120kHz
                   NaN  220  440 880];                         % ExtendedCP, 60kHz
    W = [];
    if (strcmpi(frequencyRange,'FR1'))
        rowIdx = find(carrier.SubcarrierSpacing == scsFR1) + double(strcmpi(carrier.CyclicPrefix,'extended'));
        W = WsFR1(rowIdx,nFFT == nfftFR1);
        if channelBandwidth == 25
            if nFFT == 512 && carrier.SubcarrierSpacing == 60
                if strcmpi(carrier.CyclicPrefix,'extended')
                    W = 110;
                else
                    W = 18;
                end
            elseif nFFT == 1024 && carrier.SubcarrierSpacing == 30
                W = 36;
            elseif nFFT == 2048 && carrier.SubcarrierSpacing == 15
                W = 72;
            end
        end
    else
        rowIdx = find(carrier.SubcarrierSpacing == scsFR2) + double(strcmpi(carrier.CyclicPrefix,'extended'));
        W = WsFR2(rowIdx,nFFT == nfftFR2);
    end
    % Filter out invalid combinations
    if isnan(W) || isempty(W)
        error('Invalid FFT/SCS/BW combination');
    end
end

function [H] = hChannelEstimateEVM3GPP(rxGrid,refGrid)
    % Channel estimation as defined in TS 38.104 Annex B.6(FR1)/C.6(FR2) is
    % performed, the pilots are averaged in time and frequency
    % and the resulting vector is linearly interpolated.
    [K,N,P] = size(rxGrid);

    % Extract reference indices and symbols from reference grid
    refInd = find(refGrid(:)~=0);
    refSym = refGrid(refInd);

    % Get channel estimate output dimensions, final channel estimate will
    % be of size K-by-N-by-R-by-P
    R = size(rxGrid,3);

    % Create the channel estimate grid
    H = complex(zeros([K N R P]));

    % ---------------------------------------------------------------------
    % LS estimation
    % ---------------------------------------------------------------------

    % For each transmit port
    for p = 1:P
        % Get frequency (subcarrier k) and time (OFDM symbol n) subscripts
        % of reference signal for the current port. 'thisport' is a logical
        % indexing vector for the current port, used to extract the
        % corresponding reference symbols
        [ksubs,nsubs,thisport] = getPortSubscripts(K,N,P,refInd,p);
        refSymThisPort = refSym(thisport);

        % For each OFDM symbol
        un = unique(nsubs).';
        for uni = 1:numel(un)

            % Get frequency and OFDM symbol subscripts
            n = un(uni);
            k = ksubs(nsubs==n);
            % For each receive antenna
            for r = 1:R
                % Perform least squares (LS) estimate of channel in the
                % locations of the reference symbols. 'H_LS' is a column
                % vector containing the LS estimates for all subcarriers
                % for the current port, OFDM symbol and receive antenna
                H_LS = rxGrid(k,n,r) ./ refSymThisPort(nsubs==n);

                % Assign the estimates into the appropriate region of
                % the overall channel estimate array
                H(k,n,r,p) = H_LS;
            end
        end
    end

    % Get phase (theta) and magnitude(radius) of complex estimates
    [theta,radius] = cart2pol(real(H),imag(H));

    % Declare vector to temporarily store averaged phase and
    % magnitude
    phasemagVec = zeros(size(H,1),2);

    % Perform averaging in time and frequency for phase and
    % magnitude separately and recombine at end
    for phaseOrMag = 1:2
        % Define temporary H vector and set estimates to
        % phase then magnitude
        % Initialize averaging vector used as a placeholder for both time &
        % frequency averaging directions
        avgVec = complex(zeros(size(H,1),1));
        if phaseOrMag==1
            H_EST_tmp = theta;
        else
            H_EST_tmp = radius;
        end
        % First obtain all valid rows
        row = find(sum(H_EST_tmp,2));
        for rowIdx = 1:length(row)
            currentRow = row(rowIdx);
            avgVec(currentRow)= (sum(H_EST_tmp(currentRow,:)))./length(find(H_EST_tmp(currentRow,:)));
        end
        vec = find(avgVec);
        % Remove subcarriers which contained no pilot symbols, then
        % perform frequency averaging
        avgVec = avgVec(vec);

        % 'isEven' indicates whether the length of 'avgVec' is
        % odd (0) or even (1), this is used to extract the
        % correct elements after filtering and to correctly
        % calculate the normalization factor
        isEven = (mod(length(avgVec),2)==0);

        % Perform averaging in frequency direction using a moving
        % window of size N, N = 19 in TS 38.104 Annex B.6(FR1) or C.6(FR2)
        % Performs a moving average of window size N. At the edges, where less than
        % N samples are span the window size is reduce to span 1, 3, 5, 7 ...
        % samples.
        N = 19;
        % Use filter to perform part of the averaging (not normalized)
        zeroPad = zeros(N-1,1);
        data = [avgVec; zeroPad];
        weights = ones(N,1);
        freqAvg = filter(weights,1,data);

        % 'isEvenOrLong' configures the appropriate odd or even
        % symmetry in the elements of 'freqAvg' extracted after
        % filtering and in the calculation of the normalization
        % factor
        isEvenOrLong = (isEven || length(avgVec)>=N);

        % Remove unwanted elements
        if (isEvenOrLong)
            X = N;
        else
            X = length(data);
        end
        removeIdx = [(2:2:X) (length(data) - ((X-N+2):2:N) + isEvenOrLong)];
        freqAvg(removeIdx) = [];

        % Normalization factor. As stated above and according
        % to the standard, only odd reference subcarriers 1, 3,
        % 5, 7 ... are kept when averaging less than the full
        % 19 reference subcarriers. 'M' here determines the
        % (1-based) index of the last reference subcarrier
        % kept (i.e. reference subcarriers 1:2:M are kept); for
        % length(avgVec)>=N, M = N-2 = 17, as this is the
        % last odd reference subcarrier index <19. For
        % length(avgVec)<N, M = length(avgVec)-isEven (M is the last
        % odd index whether length(avgVec) is odd or even).
        M = min(length(avgVec)-isEven,N-2);
        normFactor = [1:2:M N*ones(1,length(freqAvg)-(N-1)) (M-(1-isEvenOrLong)*2):-2:1]';
        freqAvg = freqAvg./normFactor;
        % Place frequency averaged pilots into temporary storage
        % vector
        if ~isempty(freqAvg)
            phasemagVec(vec,phaseOrMag) = freqAvg;
        end
    end
    % Convert averaged symbols back to Cartesian coordinates
    [X,Y] = pol2cart(phasemagVec(:,1),phasemagVec(:,2));
    H_tmp = complex(X,Y);

    % Interpolate coefficients to account for missing pilots
    if length(freqAvg) > 1
       interpEqCoeff = interp1(find(H_tmp~=0),H_tmp(H_tmp~=0),(1:length(H_tmp)).','linear','extrap');
    else
        interpEqCoeff = H_tmp;
        if sum(H_tmp)
            interpEqCoeff(:,1) = H_tmp(H_tmp~=0);
        end
    end
    H(:,:,R,P) = repmat(interpEqCoeff,1,size(H,2));
end

function [ksubs,nsubs,thisport] = getPortSubscripts(K,N,P,ind,port)
    % Extract a frequency-time grid (along with the associated port) from the given linear indices 
    [ksubs,nsubs,psubs] = ind2sub([K N P],ind(:));

    thisport = (psubs==port);

    ksubs = ksubs(thisport);
    nsubs = nsubs(thisport);

end


function evm = hEVM(varargin)
%   hEVM Error vector magnitude calculation
%   EVM = hEVM(...) returns a structure EVM containing error vector magnitude information.
%   EVM is a structure containing the following fields:
%   RMS  - Root Mean Square (RMS) EVM, the square root of the mean square
%          of the EVM across all input values
%   Peak - Peak EVM, the largest EVM value calculated across all 
%          input values
%   EV   - The normalized error vector

%   EVM = hEVM(X,R) returns a structure EVM for the input array X given
%   the reference signal array R. The EVM is defined using the error
%   (difference) between the input values X and the reference signal R.
%
%   EVM = hEVM(EV) returns a structure EVM for the input array EV which
%   is taken to be the normalized error vector
%   EV=(X-R)/sqrt(mean(abs(R.^2))). This allows for peak and RMS EVM
%   calculation for pre-existing normalized error vectors. This can be used
%   for example to calculate the EVM across an array of previous EVM
%   results, by extracting and concatenating the EV fields from the array
%   to form the EV input.

    if (nargin == 2)
        x = varargin{1};
        r = varargin{2};
        errorVector = x-r;
        p = sqrt(mean(abs(r(:).^2)));
        if (p == 0)
            p = 1;
        end
        evnorm = errorVector/p;
    else
        ev = varargin{1};
        evnorm = ev;
    end
    evm.EV = evnorm;
    evmsignal = abs(evnorm(:));
    evm.Peak = max(evmsignal);
    evm.RMS = sqrt(mean(evmsignal.^2));
end

function refGrid = referenceGrid(carrier,pdschArray,nSlots)
    % Create a reference grid.
    % It contains the DM-RS symbols specified in pdschArray.
    nSubcarriers = carrier.NSizeGrid * 12;
    L = carrier.SymbolsPerSlot*nSlots; % Number of OFDM symbols in the reference grid
    refGrid = zeros(nSubcarriers,L); % empty grid
    rbsPerSlot = nSubcarriers*carrier.SymbolsPerSlot;
    % Populate the DM-RS symbols in the reference grid for all slots
    for slotIdx=0:nSlots-1
        [~,~,dmrsIndices,dmrsSymbols] = hSlotResources(pdschArray,slotIdx);
        refGrid(dmrsIndices+slotIdx*rbsPerSlot) = dmrsSymbols;
    end
end

%hNRPlotPositions returns plot sizes and positions based on screen resolution
%   [REPOSITIONPLOTS,POSITION] = hNRPlotPositions() determines whether plot
%   tiling can be supported based upon the user's display resolution. If
%   plot tiling can be supported, REPOSITIONPLOTS is returned as true and
%   POSITION contains an array of vectors of the form [left bottom width
%   height] indicating the X-Y position and size for each plot. The plots
%   are arranged in a 2x3 tiled arrangement. If plot tiling cannot be
%   supported, REPOSITIONPLOTS is returned as false and POSITION is not
%   valid.
%
%   The plots are arranged in the following manner:
%    2x3 Tile
%            Plot 5    Plot 1    Plot 2
%            Plot 6    Plot 3    Plot 4

function [repositionPlots,position] = hNRPlotPositions()

    su=get(0,'Units');
    set(0,'Units','pixels');
    res = get(0,'ScreenSize');
    set(0,'Units',su);
    
    minres = 1280;
    if (res(3)>minres)
        xpos = fix(res(3)*[1/2; 3/4; 1/2; 3/4; 1/4; 1/4]);
        ypos = fix(res(4)*[1/2; 1/2; 1/16; 1/16; 1/2; 1/16]);
        xsize = (xpos(2) - xpos(1) - 20)*[1; 1; 1; 1; 1; 1];   
        ysize = fix(xsize(1) * 5 / 6)*[1; 1; 1; 1; 1; 1];
        position = [xpos ypos xsize ysize];
        repositionPlots = true;
    else
        position = zeros(6,4);
        repositionPlots = false;
    end
end

function [evmGridFigure,evmSymbolPlot,evmSubcarrierPlot,evmSlotPlot] = hNREVMPlots(varargin)
% hNREVMPlots configure plots for hNRPDSCHEVM function
% [EVMGRIDFIGURE,EVMSYMBOLPLOT,EVMSUBCARRIERPLOT,EVMSLOTPLOT] = hNREVMPlots()
% returns three dsp plot objects
% [EVMGRIDFIGURE,~,~,~] = hNREVMPlots(EVMGRIDFIGURE,EVMGRID)
% EVMGRIDFIGURE is a figure window.
% EVMGRID is a Frequency-time EVM grid which is used as an input for
% preparing a 3-D surface plot.
    if (nargin == 0)

        % Plot sizing and positioning
        [repositionPlots,plotPositions] = hNRPlotPositions();

        % EVM resource grid
        evmGridFigure = figure('Visible','off');
        evmGridFigure.Name = 'EVM (%)';
        evmGridFigure.NumberTitle = 'off';
        evmGridFigure.Color = [40 40 40]/255;

        % EVM versus subcarrier
        evmSubcarrierPlot = dsp.ArrayPlot;
        evmSubcarrierPlot.Name = 'EVM (%) versus subcarrier';
        evmSubcarrierPlot.Title = evmSubcarrierPlot.Name;
        evmSubcarrierPlot.YLabel = 'EVM (%)';
        evmSubcarrierPlot.XLabel = 'Subcarrier';
        evmSubcarrierPlot.PlotType = 'Line';
        evmSubcarrierPlot.ShowGrid = true;
        evmSubcarrierPlot.ShowLegend = true;
        channelNames = {'RMS EVM','Peak EVM'};
        evmSubcarrierPlot.ChannelNames = channelNames;

        % EVM versus OFDM symbol
        evmSymbolPlot = dsp.TimeScope;
        evmSymbolPlot.Name = 'EVM (%) versus OFDM symbol';
        evmSymbolPlot.Title = evmSymbolPlot.Name;
        evmSymbolPlot.YLabel = 'EVM (%)';
        evmSymbolPlot.TimeUnits = 'None';
        evmSymbolPlot.PlotType = 'Line';
        evmSymbolPlot.ShowGrid = true;
        evmSymbolPlot.ShowLegend = true;
        evmSymbolPlot.ChannelNames = channelNames;

        % EVM versus slot
        evmSlotPlot = dsp.TimeScope;
        evmSlotPlot.Name = 'EVM (%) versus slot';
        evmSlotPlot.Title = evmSlotPlot.Name;
        evmSlotPlot.YLabel = 'EVM (%)';
        evmSlotPlot.PlotType = 'Stairs';
        evmSlotPlot.ShowGrid = true;
        evmSlotPlot.ShowLegend = true;
        evmSlotPlot.ChannelNames = channelNames;
        if repositionPlots
            evmGridFigure.Position = plotPositions(1,:);
            evmSubcarrierPlot.Position = plotPositions(2,:);
            evmSymbolPlot.Position = plotPositions(3,:);
            evmSlotPlot.Position = plotPositions(4,:);
        end
    else
        % Display a 3-D surface plot using evmGrid
        evmGridFigure = varargin{1};
        evmGrid = varargin{2};

        figure(evmGridFigure);
        surf(evmGrid);
        shading flat;
        evmGridFigure.CurrentAxes.XColor = [175 175 175]/255;
        evmGridFigure.CurrentAxes.YColor = [175 175 175]/255;
        evmGridFigure.CurrentAxes.ZColor = [175 175 175]/255;
        evmGridFigure.CurrentAxes.Color = [0 0 0];
        evmGridFigure.CurrentAxes.XGrid = 'on';
        evmGridFigure.CurrentAxes.YGrid = 'on';
        evmGridFigure.CurrentAxes.ZGrid = 'on';
        evmGridFigure.CurrentAxes.XLabel.String = 'OFDM symbols';
        evmGridFigure.CurrentAxes.XLabel.FontSize = 8;
        evmGridFigure.CurrentAxes.YLabel.String = 'Subcarriers';
        evmGridFigure.CurrentAxes.YLabel.FontSize = 8;
        evmGridFigure.CurrentAxes.ZLabel.String = 'EVM (%)';
        evmGridFigure.CurrentAxes.ZLabel.FontSize = 8;
        evmGridFigure.CurrentAxes.View = [-30 60];
        evmGridFigure.CurrentAxes.XLim = [0 size(evmGrid,2)+1];
        evmGridFigure.CurrentAxes.YLim = [0 size(evmGrid,1)+1]; 
    end
end
